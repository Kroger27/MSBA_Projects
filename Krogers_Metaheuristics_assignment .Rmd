---
title: "Krogers_Metaheuristics_assignment"
output: html_document
---
```{r}
library(GenSA)
library(ggplot2)
library(GA)
```

```{r}
 fun = function(x,y) { (sin(10*x)*cos(10*y)+2)/sqrt(x^4+y^4+1) } 
 obj = function(z) { -fun(z[1],z[2])}
 lower <- c(-3,-3)
upper <- c(3,3)
par <- c(2,2)
```

```{r}
x=seq(-3,3,length=50) # tick marks on x axis
y=seq(-3,3,length=50) # tick marks on y axis; defines grid for... 
z=outer(x,y,fun) # matrix for plotting -- z vals / height of surface
 persp3D(x, y, z, phi = 0, theta = 45,
  xlab = "X", ylab = "Y",
  main = "Surface elevation data",
  color.palette = bl2gr.colors
)
filled.contour(x, y, z, color.palette = bl2gr.colors)
```

```{r}
out <- GenSA(par=par,lower=lower,upper=upper,fn=obj)
out[c("value","par","counts")]
filled.contour(x, y, z, color.palette = bl2gr.colors, 
      plot.axes = { axis(1);
                    axis(2); points(out$par[1],out$par[2],
                                    cex=2,col="red",lwd=2)}
)
```


```{r}
 nfun = function(x) {
   (12*x^5-975*x^4+28000*x^3-345000*x^2+1800000*x)
 }
ll = c(0)
ul = c(31)

# Plot the function
# Note, plotting as a maximization function
p <- ggplot(data=data.frame(x=0),aes(x=x))
p + stat_function(fun=nfun) + xlim(0,31)
```

```{r}
nfun1 = function(x) { -nfun(x)}
ll = c(0)
ul = c(31)
par = 2
out1 <- GenSA(par=par,lower=ll,upper=ul,fn=nfun1)
out1[c("value","par","counts")]
curve(nfun, from = 0, to = 31, n = 1000)
points(out1$par[1],-out1$value, col = 2, pch = 19)
```

```{r}
library("quantmod")
tickers <- c("GE", "IBM", "JPM", "MSFT", "WMT")
getSymbols(tickers, from = "2000-12-01", to = "2010-12-31")
P <- NULL
for(ticker in tickers) {
 tmp <- Cl(to.monthly(eval(parse(text = ticker))))
 P <- cbind(P, tmp)
}
colnames(P) <- tickers
R <- diff(log(P))
R <- R[-1,]
mu <- colMeans(R)
sigma <- cov(R)
library("PerformanceAnalytics")
pContribCVaR <- ES(weights = rep(0.2, 5), method = "gaussian", portfolio_method = "component", mu = mu, sigma = sigma)$pct_contrib_ES
obj <- function(w) {
 fn.call <<- fn.call + 1
 if (sum(w) == 0) { w <- w + 1e-2 }
 w <- w / sum(w)
 CVaR <- ES(weights = w, method = "gaussian", portfolio_method = "component", mu = mu, sigma = sigma)
 tmp1 <- CVaR$ES
 tmp2 <- max(CVaR$pct_contrib_ES - 0.225, 0)
 out <- tmp1 + 1e3 * tmp2
 return(out)
}
```

#Question 1
dear Professor Shanker, 
I tried to run the "Summary and Plot" function but for some strange reason it wasn't executing. Below is the the example of the code I tired to run, I pass by your office today around 11:45 but you wasn't in your office.
Regards,
Kareem 

summary(gap_2)
plot(gap_2)
```{r}
Rastringin <- function(w)
gap_2 <- ga(type = "real-valued", fitness =obj, lower=rep(0, 5),upper=rep(1, 5), popSize = 50, maxiter = 150)
curve(nfun, from = 0, to =31, n = 1000)
points(20, 4.4e+06, col=2,pch= 19)
```

#Question 2

```{r}
x <- c(61,63,67,69,70,74,76,81,86,91,95,97)
y <- c(4.28,4.08,4.42,4.17, 4.48,4.3,4.82,4.7,5.11,5.13,5.64,5.56)
fun =function(x,y) {(sin(10*x)*cos(10*y)+2)/sqrt(x^4+y^4+1)}
obj = function(z)
{
  fn.call <<- fn.call + 1
  ssyy=sum((y-mean(y))^2)
  ssxy=sum((x-mean(x))*(y-mean(y)))
  ssx=sum((x-mean(x))^2)
  b1= ssxy/ssx
  b0=mean(y)-b1*mean(x)
  y_estimated = x*b1+b0
  residuals = y-y_estimated
  sse=sum((residuals - mean(residuals))^2)
  out <- sse
  return(out)
}
```


```{r}
set.seed(1234)
fn.call <<- 0
out.GenSA <- GenSA(fn = obj, lower =rep (0,2), upper =rep(5,2), control = list (smooth = F, max.call=3000))
fn.call.GenSA <- fn.call
out.GenSA$value
out.GenSA$counts
cat("GenSa call funtions", fn.call.GenSA, "times.\n")
```

```{r}
gap <- ga(type = "real-valued",fitness=obj, lower =rep(0, 2), upper =rep(5, 2), popSize =50, maxiter =150)
summary(gap)
plot(gap)
```










```{r}
set.seed(1234)
fn.call <<- 0
out.GenSA <- GenSA(fn = obj, lower = rep(0, 5), upper = rep(1, 5), control = list(smooth = FALSE, max.call = 3000))
fn.call.GenSA <- fn.call
out.GenSA$value
out.GenSA$counts
cat("GenSA call functions", fn.call.GenSA, "times.\n")
wstar.GenSA <- out.GenSA$par
wstar.GenSA <- wstar.GenSA / sum(wstar.GenSA)
rbind(tickers, round(100 * wstar.GenSA, 2))
100 * (sum(wstar.GenSA * mu) - mean(mu))
```



```{r}
library(ggplot2)
library(GA)
```

```{r}
# The following function requires two inputs
# Limits are (-3,-3) to (3, 3)
 fun = function(x,y) { (sin(10*x)*cos(10*y)+2)/sqrt(x^4+y^4+1) } 
 obj = function(z) { fun(z[1],z[2])}
 
# Plot the function
x=seq(-3,3,length=50) # tick marks on x axis
y=seq(-3,3,length=50) # tick marks on y axis; defines grid for... 
z=outer(x,y,fun) # matrix for plotting -- z vals / height of surface
 persp3D(x,y, z, phi = 0, theta = 45,
  xlab = "X", ylab = "Y",
  main = "Surface elevation data",
  color.palette = bl2gr.colors,
  ticktype = "detailed"
)
filled.contour(x, y, z, color.palette = bl2gr.colors)

```

```{r}
library(GA)
lower = c(-3,-3)
upper = c(3,3)
# Visualize the solution
monitor <- function(obj) 
{ 
  contour(x, y, z, drawlabels = FALSE, col = grey(0.5))
  title(paste("iteration =", obj@iter), font.main = 1)
  points(obj@population, pch = 20, col = 2)
  Sys.sleep(0.2)
}

GA1 <- ga(type = "real-valued",fitness=obj,lower=lower,upper=upper, popSize = 50)
summary(GA1)
plot(GA1)


filled.contour(x, y, z, color.palette = bl2gr.colors, 
      plot.axes = { axis(1);
                    axis(2); points(GA1@solution[,1],GA1@solution[,2],
                                    cex=2,col="red",lwd=2)}
)

```

```{r}
 nfun = function(x) {
   (12*x^5-975*x^4+28000*x^3-345000*x^2+1800000*x)
 }
ll = c(0)
ul = c(31)

# Plot the function
# Note, plotting as a maximization function
p <- ggplot(data=data.frame(x=0),aes(x=x))
p + stat_function(fun=nfun) + xlim(0,31)
```

```{r}
nfun1 = function(x) {
   (12*x^5-975*x^4+28000*x^3-345000*x^2+1800000*x)
 }
GA2 <- ga(type = "real-valued",fitness=nfun1, lower=0,upper=31)
summary(GA2)
plot(GA2)
curve(nfun1, from = 0, to = 31, n = 1000)
points(GA2@solution, GA2@fitnessValue, col = 2, pch = 19)
```

